generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String  @id @default(cuid())
  email        String  @unique
  name         String?
  
  contacts            Contact[]
  contributions       Contribution[]
  autobiographyEntries AutobiographyEntry[]
  fulfillmentAreas    FulfillmentArea[]
  commitments         Commitment[]
  interactions        Interaction[]
  assessments         RelationshipAssessment[]
  boundaryAudits      BoundaryAudit[]
  contactLinks        ContactLifeAreaLink[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Contact {
  id            String  @id @default(cuid())
  userId        String
  firstName     String
  lastName      String
  email         String?
  phoneE164     String?
  hubspotId     String?
  salesforceId  String?
  notes         String?
  tags          String[]
  
  user          User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  lifeAreaLinks ContactLifeAreaLink[]
  interactions  Interaction[]
  assessments   RelationshipAssessment[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@unique([userId, email])
  @@index([userId])
  @@index([lastName, firstName])
}

model LifeArea {
  id          Int     @id
  name        String  @unique
  icon        String?
  description String?
  
  contactLinks     ContactLifeAreaLink[]
  fulfillmentAreas FulfillmentArea[]
  interactions     Interaction[]
  assessments      RelationshipAssessment[]
  boundaryAudits   BoundaryAudit[]
}

model ContactLifeAreaLink {
  id          String  @id @default(cuid())
  userId      String
  contactId   String
  lifeAreaId  Int
  roleLabel   String?
  frequency   String?
  weight      Float?
  outcomes    String?
  notes       String?
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  contact     Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  lifeArea    LifeArea @relation(fields: [lifeAreaId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([contactId, lifeAreaId])
  @@index([userId])
  @@index([contactId])
  @@index([lifeAreaId])
}

model Contribution {
  id        String  @id @default(cuid())
  userId    String
  type      ContributionType
  title     String
  content   String?
  source    String?
  tags      String[]
  color     String?
  
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
}

enum ContributionType {
  strength
  acknowledgment
  natural
  quote
}

model AutobiographyEntry {
  id         String  @id @default(cuid())
  userId     String
  year       Int
  title      String?
  narrative  String?
  earliest   String?  // earliest similar occurrence
  insight    String?  // what I made it mean
  commitment String?  // new way of being
  lifeAreas  Int[]    // array of life area ids
  tags       String[]
  
  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@unique([userId, year])
  @@index([userId, year])
}

model FulfillmentArea {
  id         String  @id @default(cuid())
  userId     String
  lifeAreaId Int
  status     FulfillmentStatus @default(thriving)
  attention  Int?    @db.SmallInt
  notes      String?
  
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  lifeArea   LifeArea    @relation(fields: [lifeAreaId], references: [id])
  commitments Commitment[]
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@unique([userId, lifeAreaId])
  @@index([userId])
}

enum FulfillmentStatus {
  thriving
  attention
  collapse
}

model Commitment {
  id       String  @id @default(cuid())
  userId   String
  areaId   String
  title    String
  outcome  String?
  
  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  area     FulfillmentArea @relation(fields: [areaId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
  @@index([areaId])
}

model Interaction {
  id             String  @id @default(cuid())
  userId         String
  contactId      String
  lifeAreaId     Int?
  occurredAt     DateTime @default(now())
  channel        InteractionChannel
  direction      InteractionDirection @default(internal)
  subject        String?
  bodyText       String?
  bodyHtml       String?
  uri            String?
  sentiment      Sentiment?
  sentimentScore Float?
  topics         String[]
  entities       Json?
  meta           Json @default("{}")
  
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  contact   Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  lifeArea  LifeArea? @relation(fields: [lifeAreaId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([contactId, occurredAt])
  @@index([lifeAreaId, occurredAt])
}

enum InteractionChannel {
  call
  sms
  email
  meeting
  note
  whatsapp
  telegram
  signal
  messenger
  other
}

enum InteractionDirection {
  inbound
  outbound
  internal
}

enum Sentiment {
  very_negative
  negative
  neutral
  positive
  very_positive
}

model RelationshipAssessment {
  id            String   @id @default(cuid())
  userId        String
  contactId     String
  lifeAreaId    Int
  assessedOn    DateTime @default(now()) @db.Date
  trustScore    Float?
  communication Float?
  reliability   Float?
  openness      Float?
  growth        Float?
  reciprocity   Float?
  alignment     Float?
  overall       Float?
  notes         String?
  
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  contact  Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  lifeArea LifeArea @relation(fields: [lifeAreaId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@unique([userId, contactId, lifeAreaId, assessedOn])
  @@index([userId])
  @@index([contactId, lifeAreaId, assessedOn])
}

model BoundaryAudit {
  id         String   @id @default(cuid())
  userId     String
  lifeAreaId Int?
  timestamp  DateTime @default(now())
  incident   String
  response   String?
  learning   String?
  
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  lifeArea LifeArea? @relation(fields: [lifeAreaId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@index([userId, timestamp])
}